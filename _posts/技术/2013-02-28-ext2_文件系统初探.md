---
layout: post
title: ext2 文件系统初探
category: 技术
tags: Linux File_System
keywords: 
description: 
---
在平时有没有好奇过，同一个分区下的文件移动几乎是不需要时间的，即使那个文件十分的巨大，但是在不同分区移动时，却是相当的耗时。有没有好奇过文件夹到底是个什么东西，我们是怎么一步步找到文件的。本篇博文将以*ext2*文件系统为例尽量解开这个疑问。

*Ext2*文件系统是经典的*Linux*系统，*ext2*和*ext3*是目前*Linux*系统的主要文件系统。

在一般的文件系统中，可访问的磁盘的最小单位是块（*block*），也就是说一个非空文件至少占用一个*block*（块大小一般为*2KB，4KB*或*8KB*），块是文件系统管理这个磁盘的基本单位，一般情况下每个*block*在一个分区中有一个独一无二的*32bits*整数表示的块号，通过块号可以在一个分区中找到对应的块的位置。我们可能不会太多的涉及组的东西，只从最基础的角度理解文件系统。在*Linux*中主要的文件类型有7种，分别是：普通文件，目录，字符设备，块设备，命名管道，套接字和符合链接，分别由数值1-7来代表。我们主要将目光集中在普通文件，目录和符号链接上。

假设有下面这样的一个文件夹，分别有三个文件（*file_1,file_2,file_3*）和子目录(*foder_1, folder_2, folder_3*)，三个子目录中又分别有三个文件(*file_11,file_12, file_13; file_21, file_22, file_23; file_31, file_32, file_33*)。本文都是一个这个目录为例展开。

![folder_structure](/public/img/ext2/1.PNG)

下面我就集中在*inode*的结构上。按照*POSIX*的规定，*inode*节点至少要存储以下信息（只列出常见的条目）：

- 文件大小（*Byte*为单位）
- 文件拥有者的*ID*
- 文件的访问控制
- 时间戳
- 硬链接计数（后边会涉及）
- 指向用户数据的块指

其中指向用户数据的块指针一共15个，其中12个直接块指针，一级、二级、三级块指针各一个。假设一个块的大小为b字节，12个直接块指针直接指向12个块，也就是说通过直接访问的用户数据可以有12b字节；一级间接指针首先指向一个块，但是此块内部数据为块指针（也就是块号），由于块号都是4字节大小的，所以通过一级间接指针可以访问<img src="http://latex.codecogs.com/gif.latex?\frac{b^2}{4}" title="\frac{b^2}{4}" />字节大小的数据，二级和三级间接指针以此类推，容易得到一个文件的大小最大为<img src="http://latex.codecogs.com/gif.latex?\left&space;[&space;(\frac{b}{4})^3&plus;(\frac{b}{4})^2&plus;\frac{b}{4}&plus;12&space;\right&space;]\times&space;b" title="\left [ (\frac{b}{4})^3+(\frac{b}{4})^2+\frac{b}{4}+12 \right ]\times b" />；如下图（摘自[《深入理解Linux内核》](http://www.amazon.com/Understanding-Linux-Kernel-Third-Edition/dp/0596005652/ref=sr_1_1?ie=UTF8&qid=1414327369&sr=8-1&keywords=understanding+linux+kernel)）

![Snap](/public/img/ext2/2.PNG)

从上面得知目录也是一个文件，但是目录中文件的内容有些特殊，目录文件中存放的数据相当于是一对对的*pair，<文件名，对应inode所在位置>*。

为了效率的考虑，每对*pair*的长度都补齐到4的整数倍，示例如下图（摘自*《深入理解Linux内核》*），其中第二列代表下一条记录相对于本条目录的偏移量，当我们访问目录下的一个文件时，就像访问链表一样，从开始进行遍历，直到找到匹配的文件名，然后按照得到的相应的*inode*继续进行访问。很容易看到当一个目录下存在的表项十分多时，访问位置靠后的文件是十分缓慢的，这也是*ext2*文件系统的一个劣势。注意，其中的*olderfile*是已经删除的文件，仔细观察文件系统是如何修改这个表项的（将要删除的文件的对应表项的*inode*改为0，同时将这个表项的上一条表项的偏移值加上要删除的表项的偏移值，其实并没有真正的将这个表项删除，只是跳过了这个表项而已）。

![Snap2](/public/img/ext2/3.PNG)

我们做如下实验：
创建一个新的目录*test2*，里面只存放一个*bat.py*的*python*脚本语言，这个脚本功能很简单就是创建*10000*个空文件，文件名为*0-9999*。我们输入的命令为

``` 
stat .
python bat.py
stat .
ls -la | wc
rm [0-9]*
ls -la | wc
stat .
```

其中stat命令可以查看一个文件大小等信息。
得到的结果如下，随着目录下的文件数目的增加，目录表项会增加，目录文件的大小也是增加的，但是当把文件删除时，并不能看到目录文件的减小，这就是由于上面的那种文件删除方式造成的。

![Snap3](/public/img/ext2/4.PNG)

有了以上的知识，我们可以分析一下文件系统是如何访问一个文件的。

![Snap4](/public/img/ext2/5.PNG)

如上图，假如我们要访问*folder_3/file_33*文件中的内容，假设当前已经到达节点号为1的*inode*节点，文件系统会到该目录的表项中查找*folder_3*的表项，根据上图得到*folder_3*对应的inode节点号为7，文件系统会访问*inode* 7这个节点，*inode*节点中存放在指向用户数据块的块指针，文件系统沿着这个块指针找到这个数据块，使用同样的方式找到*file_33*文件对应的*inode*节点号为10，然后沿着*inode* 10访问该文件中的数据，至此成功访问到我们想要的数据(*file_33's data*)。

在每个目录中都存在两个特殊的目录( . )和( .. ), 他们分别代表着当前目录和上一级目录，他们是使用马上就要讲到的硬链接技术实现的。

在*Linux*系统中查看一个文件的*inode*号，可以使用 *stat* 或者* ls –i* 命令，如下查看*file_1*的*inode*内的信息，可以输入* stat file_1*，得到

![Snap5](/public/img/ext2/6.PNG)

可以看到其中包括所有的元数据信息.
每个*inode*节点内都有一个硬链接计数，一个*inode*节点只能对应一个文件。通过link命令可以为文件创建一个硬链接命令格式是： *link oldfile newfile*
假设我们输入以下两行命令

```
link file_1 file_1_new
stat file_1
```

得到的结果如下：

![Snap6](/public/img/ext2/7.PNG)

第一个行命令是给*file_1*创建一个硬链接取名为*file_1_new*,第二行命令打印出*file_1*对应的*inode*节点的信息，会发现唯一变化的两个选项是“硬链接计数”从1变为2，“更改时间”发生变化。其实*link file_1 file_1_new* 命令的作用就是在目录文件下面增加一项，*<file_1_new, 2>*, 目录文件的内容变化为：

![Snap7](/public/img/ext2/8.PNG)

可以清晰的看到，有两个目录表项指向索引号为2的*inode*节点，所以该节点的硬链接计数增加为2。根据这个分析，其实可以得到一般情况下一个目录的inode节点硬链接计数就等于该目录下所有可见及不可见的子目录的个数之和。这是由于每个目录中存在两个特殊的目录( . )和( .. ), 分别为当前目录和上一级目录的硬链接。以图1为例，*ext2*目录文件的硬链接计数为5，分别是*( . ), folder_1/.. , folder_2/.. , folder_3/..*, 还有一个是ext2目录的上一级目录指向ext2的一个表项，因此总共5个硬链接。而ext2下的目录总共也是5个：*( . ), ( .. ), folder_1, folder_2, folder_3*。只要不存在额外的硬链接，一个目录的硬链接计数就是它的所有的子目录的个数。

虽然硬链接的规则不准许我们对目录进行硬链接，但是根据我们的分析，目录下的两个特殊目录的确是对目录的硬链接，不过这个过程由文件系统管理的。

看到硬链接，当然也存在软链接，也叫做符号链接。创建一个符号链接时，其实文件系统会创建一个实实在在的文件，但文件的内容是所链接的路径。创建符号链接的指令是*link –s Oldfile  newfile*, 如我们输入以下指令：*link –s file_2 file_2_new*

上图会变为：

![Snap8](/public/img/ext2/9.PNG)

符号链接也不会影响*inode*的链接计数，值得注意的是，当路径很短时，其实并不需要一个块专门用来存放这个路径，而是将路径放在inode的节点中(*inode*中是可以存放一些简单的信息的)，也就是上图节点8中，这样可以节省磁盘空间，并且加快访问的速度。

通过上面的分析，下面列出的硬链接和符号链接的性质就是显而易见的了，也很容易分析为什么具有这些性质。

硬链接的特性：

- 文件有相同的 inode 及文件数据；
- 只能对已存在的文件进行创建；
- 不能交叉文件系统进行硬链接的创建；
- 不能对目录进行创建，只可对文件创建；
- 删除一个硬链接文件并不影响其他有相同 inode 号的文件。

软链接的特性：

- 软链接有自己的文件属性及权限等；
- 可对不存在的文件或目录创建软链接；
- 软链接可交叉文件系统；
- 软链接可对文件或目录创建；
- 创建软链接时，链接计数不会增加；
- 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 *dangling link*，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

现在再回到初始提到的问题，为什么一个分区内的文件移动速度非常快的呢，那是因为移动文件时，文件系统所做的操作是很少的。比如说命令 *mv file_1 folder_1/*, 文件系统仅仅是将当前目录的表项删除其中一项（虽然并未真正删除），然后在*folder_1*的目录表现中增加一项，根本没有去移动文件的内容。而在不同分区移动文件时，文件系统就要老老实实的一个字节一个字节的进行拷贝了，所以两者的耗时不是一个数量级的。