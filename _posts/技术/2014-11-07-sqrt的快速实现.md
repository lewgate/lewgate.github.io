---
layout: post
title: sqrt的快速实现
category: 技术
tags: 算法
keywords: 
description: 
---

在浏览知乎的时候无意间看到一个有意思的问题[一百行以下有哪些给力代码](http://www.zhihu.com/question/26483508)，其中有一个很有意思的求单精度浮点数开方根的程序，程序大致如下

``` C
float Sqrt(float x){
	float xhalf = 0.5f*x;
	int i = *(int *)&x;
	i = 0x5f375a86-(i>>1);
	x = *(float *)&i;
	x = x*(1.5f-xhalf*x*x);
	x = x*(1.5f-xhalf*x*x);
	x = x*(1.5f-xhalf*x*x);
	return 1/x;
}
```

在这片[文章](http://www.cnblogs.com/pkuoliver/archive/2010/10/06/sotry-about-sqrt.html)中作者提到这个方法的速度比C的库函数sqrt还要快上4倍，感到很惊奇，于是在我的机器上(Debian 7.0)跑了一下，发现其实还是比库函数sqrt慢一点，但是这也丝毫不影响研究一下这个小程序的好奇心。这段程序先是求解*1/sqrt(x)*，算法采用的仍然是[牛顿迭代法](http://en.wikipedia.org/wiki/Newton's_method)，只不过只是循环了三次，甚至一次也可以。所以这个程序的最有意思之处在于x初始值的设置，通过一步寻找到一个十分接近真实解的估计值然后通过一两步的迭代达到精度要求范围以内的数值。

初始值的设置上最核心的代码只有这一行：

``` C
i = 0x5f375a86-(i>>1);
```

乍一看不知道这行代码到底什么意思。但是看到有左移以为，我们就感觉这行代码应该和*float*的存储形式有关，在指数位置的除以2等同于开平方。那么单精度类型的内存是怎么分布的呢？来看[wiki](http://en.wikipedia.org/wiki/IEEE_754-1985)的介绍，如下图：

![folder_structure](/public/img/sqrt/618px-IEEE_754_Single_Floating_Point_Format_svg.png)

因为我们这里是求一个正数的平方根，所以不考虑符号位的情况。假设将指数位和尾数位单独观察，指数为是8bits(记为b)，尾数是23bits(记为a)，则它表示的数值为<img src="http://latex.codecogs.com/gif.latex?(1&plus;a)2^{b-127}\quad a\in [0, 1)" title="(1+\frac{a}{2^{24}})2^{b-127}" />
我们先看一个特殊的情况：b为偶数(当右移一位的时候不会从指数位传导到尾数位)，并且假设<img src="http://latex.codecogs.com/gif.latex?b=2c" title="b=2c" />，这样下来让我在分析这个代码，让我们先看*0x5f375a86*这个神奇数字， 他的指数为190，这行代码对指数位的影响是从*b-127*变成了<img src="http://latex.codecogs.com/gif.latex?-\frac{b}{2}&plus;63" title="-\frac{b}{2}+63" />这已经和*1/sqrt(x)*很接近了。为了跟进一步的接近我们需要分析*0x5f375a86*的后23bits，我们假设这个数字是*m*,经过这行代码之后尾数从*1+a*变成了*1+m-a/2*，所以总体上数值从<img src="http://latex.codecogs.com/gif.latex?(1&plus;a)^{b-127}" title="(1+a)^{b-127}" />变成<img src="http://latex.codecogs.com/gif.latex?(1&plus;m-\frac{a}{2})^{-\frac{b}{2}&plus;63}" title="(1+m-\frac{a}{2})^{-\frac{b}{2}+63}" />，令
本文大致分析一下C语言中的类型转换和计算时的溢出情况。本篇博客的主要参考文献依然是《深入理解操作系统—程序员的视角》，这本书值得强烈推荐。我们将C语言中的类型转换根据位宽是否发生变化分为下面几种：`1）位宽不发生变化的类型转换；2）扩展位宽的类型转换；3）截断位宽的类型变换；4）C++中引用的一个小特性`。分别举例为：

``` C
1) short int v = -12345;
   unsigned short uv = (unsigned short) v;
2) short sx = -12345;
   int x = sx;
3) int x = 53191;
   short sx = (short) x
```

###1. 位宽不发生变化的类型转换

浮点型到整形的转换和整形到浮点型的转换我们是不考虑的，因此我们只考虑符号数和无符号数的转换。在C语言中，大多数数字都默认是有符号的。当声明一个像12345或者0x1A2B这样的常量时，这个值被认为是有符号的。如果想创建一个无符号的常量，需要加上后缀‘U’或者‘u'。

**对于符号数和无符号数之间的转换，C语言的转换原则是底层的位表示保持不变。**

显式的强制类型变换会导致转换的发生，同时一个类型的数值赋值给另外一种类型时也会发生转换。当C语言处理同时包含有符号和无符号数的表达式时，会出现一些奇特的行为。当执行一个运算是，如果表达式内有符号数也有无符号数，那么C语言会隐式地将有符号数参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行运算。下面是一个*《深入理解计算机系统》*的表格:

```
    表达式                   类型                 求值
    0 == 0U                 无符号                  1
    -1 < 0                  有符号                  1
    -1 < 0U                 无符号                  0
2147483647 > -2147483647-1  有符号                  1
2147483647U> -2147483647-1  无符号                  0
2147483647>(int)2147483648U 有符号                  1
    -1 > -2                 有符号                  1
 (unsigned) -1 > -2         无符号                  1
```

###2. 扩展位宽的类型转换

根据我们人类的思维，当从一种类型的数值向另外一种类型的数值转换时，我们期望他们的数值是不变的。当从较小的数据类型转换到一个较大的类型时，这个期望绝大部分时候是可以达到的。*C*语言采取以下原则：将一个无符号数转换为一个更大的数据类型，采用零扩展；将一个补码数字转换为一个更大的类型执行的是符号扩展。但是有时候从一个较小类型向较大类型转换时，较大的类型并不能保证数值不变，例如：

``` C
short sx = -12345;
unsigned int uy = sx;
```

在这种情况下，数据类型的转换路线为`short->signed int->unsigned int`;这个规则是*C*的标准所规定的。此外，在C语言中，会自动进行类型提升。*C*语言要求，在表达式中*char，short*类型会被自动提升为*int*类型，例如以下表达式

``` C
sizeof('A')
char c1, c2;
char c = c1 + c2;
```

当计算上面的加法的时候，首先将*c1，c2*提升到*int*，然后相加，再将*int*截断为*char*类型。

###3. 截断位宽的类型变换

相比扩展位宽的类型变换，截断显得简单的多，直接在位域上进行截断，然后进行解释。文章开始的例子中：

``` C
int x = 53191;
short sx = (short) x;   /* -12345 */
```

###4. C++中引用的一个小特性

*C++*中一个*const* 引用是可以指向一个临时变量的，而非*const*引用是不可以的，如下例：

``` C
long l = 2222;
short const &s = l;
                                        
l = 0;
cout<<l<<"， "<<s<<endl;
```

程序会输出什么呢？不是0, 0，而是0,2222。这是由于第二行代码中的左值和右值的类型不同，编译器会生成一个临时变量，这个变量的类型为*short*，然后将*s*和这个临时变量绑定。当改变l的大小为0时，这个临时变量并没有发生变化。同样如果将第二行代码中的*const*关键字删除，编译器会编译出错。这种现象在函数调用中也广泛存在，如下例

``` C++
void funA(string & str){...}
int main(){
    funA("abcd");
}
```

编译同样会出现错误，但是如果将*funA*定义为

``` C++
void funA(const string &str){...}
```

就可以编译通过并运行，编译器首先会调用*string*类的构造函数，生成一个临时*string*对象，然后对这个临时*string*对象引用，然后完成函数的操作。