---
layout: post
title: C语言中的类型转换
category: 技术
tags: C
keywords: 
description: 
---

本文大致分析一下C语言中的类型转换和计算时的溢出情况。本篇博客的主要参考文献依然是《深入理解操作系统—程序员的视角》，这本书值得强烈推荐。我们将C语言中的类型转换根据位宽是否发生变化分为下面几种：`1）位宽不发生变化的类型转换；2）扩展位宽的类型转换；3）截断位宽的类型变换；4）C++中引用的一个小特性`。分别举例为：

``` C
1) short int v = -12345;
   unsigned short uv = (unsigned short) v;
2) short sx = -12345;
   int x = sx;
3) int x = 53191;
   short sx = (short) x
```

###1. 位宽不发生变化的类型转换

浮点型到整形的转换和整形到浮点型的转换我们是不考虑的，因此我们只考虑符号数和无符号数的转换。在C语言中，大多数数字都默认是有符号的。当声明一个像12345或者0x1A2B这样的常量时，这个值被认为是有符号的。如果想创建一个无符号的常量，需要加上后缀‘U’或者‘u'。

**对于符号数和无符号数之间的转换，C语言的转换原则是底层的位表示保持不变。**

显式的强制类型变换会导致转换的发生，同时一个类型的数值赋值给另外一种类型时也会发生转换。当C语言处理同时包含有符号和无符号数的表达式时，会出现一些奇特的行为。当执行一个运算是，如果表达式内有符号数也有无符号数，那么C语言会隐式地将有符号数参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行运算。下面是一个*《深入理解计算机系统》*的表格:

```
    表达式                   类型                 求值
    0 == 0U                 无符号                  1
    -1 < 0                  有符号                  1
    -1 < 0U                 无符号                  0
2147483647 > -2147483647-1  有符号                  1
2147483647U> -2147483647-1  无符号                  0
2147483647>(int)2147483648U 有符号                  1
    -1 > -2                 有符号                  1
 (unsigned) -1 > -2         无符号                  1
```

###2. 扩展位宽的类型转换

根据我们人类的思维，当从一种类型的数值向另外一种类型的数值转换时，我们期望他们的数值是不变的。当从较小的数据类型转换到一个较大的类型时，这个期望绝大部分时候是可以达到的。*C*语言采取以下原则：将一个无符号数转换为一个更大的数据类型，采用零扩展；将一个补码数字转换为一个更大的类型执行的是符号扩展。但是有时候从一个较小类型向较大类型转换时，较大的类型并不能保证数值不变，例如：

``` C
short sx = -12345;
unsigned int uy = sx;
```

在这种情况下，数据类型的转换路线为`short->signed int->unsigned int`;这个规则是*C*的标准所规定的。此外，在C语言中，会自动进行类型提升。*C*语言要求，在表达式中*char，short*类型会被自动提升为*int*类型，例如以下表达式

``` C
sizeof('A')
char c1, c2;
char c = c1 + c2;
```

当计算上面的加法的时候，首先将*c1，c2*提升到*int*，然后相加，再将*int*截断为*char*类型。

###3. 截断位宽的类型变换

相比扩展位宽的类型变换，截断显得简单的多，直接在位域上进行截断，然后进行解释。文章开始的例子中：

``` C
int x = 53191;
short sx = (short) x;   /* -12345 */
```

###4. C++中引用的一个小特性

*C++*中一个*const* 引用是可以指向一个临时变量的，而非*const*引用是不可以的，如下例：

``` C
long l = 2222;
short const &s = l;
                                        
l = 0;
cout<<l<<"， "<<s<<endl;
```

程序会输出什么呢？不是0, 0，而是0,2222。这是由于第二行代码中的左值和右值的类型不同，编译器会生成一个临时变量，这个变量的类型为*short*，然后将*s*和这个临时变量绑定。当改变l的大小为0时，这个临时变量并没有发生变化。同样如果将第二行代码中的*const*关键字删除，编译器会编译出错。这种现象在函数调用中也广泛存在，如下例

``` C++
void funA(string & str){...}
int main(){
    funA("abcd");
}
```

编译同样会出现错误，但是如果将*funA*定义为

``` C++
void funA(const string &str){...}
```

就可以编译通过并运行，编译器首先会调用*string*类的构造函数，生成一个临时*string*对象，然后对这个临时*string*对象引用，然后完成函数的操作。