---
layout: post
title: 我的Windows钩子
category: 技术
tags: Windows_Hook, Parttime_Job
keywords: 
description: 
---

# 我的*Windows*钩子


   本人研究僧一枚，为了糊口不得已在业余时间干起兼职，当然也有出于找工作的考虑（希望以上不要被老板看到）。在这个小小的程序开发中（其实自己都不好意思称作项目），需要用到键盘全局钩子的东西。大家一定知道，实现键盘和鼠标的全局钩子有两种不同的方式：*Low-Level*的钩子和基于*DLL*注入的全局钩子。虽然*MSDN*中建议大家使用一个*Raw Input*东西。但是出于惰性和惯性，我们仍然采用了*DLL*全局钩子的方式。悲催的是一开始就遇到一个幽灵般的问题：安装全局钩子的程序（记为程序*A*，即调用*SetWindowsHookEx*的程序）在前台时钩子可以正常工作，但是当程序A进入后台运行时（即其他程序进入激活状态时），钩子会加载失败。对于程序的*Debug*，最头疼的问题就是问题若隐若现，有时出现有时不出现。我遇到的第一个问题就是这样的。所谓“出师未捷身先死”估计就是这样了，眼看赚第一桶金的机会就要溜走了，那个揪心啊。开始疯狂的在网上翻阅资料，但是还是没有解决。最终决定到MSDN中寻找答案，终于在*MSDN*中找到了[答案](http://msdn.microsoft.com/en-us/library/windows/desktop/ms644985%28v=vs.85%29.aspx)，文章中有这么一句 _If the hook procedure times out, the system passes the message to the next hook. However, on Windows 7 and later, the hook is silently removed without being called. There is no way for the application to know whether the hook is removed_
   考虑到我的钩子的回调函数中存在着大量的操作，猜测就是由于操作过于复杂导致时间超时。于是当把回调函数中的最耗时的一个函数删除时，*Bingo*，丝毫没有问题，*Bug*就此基本确定，下面只需要实现“曲线救国”就可以了。下面我们来解释一下上面的问题，这涉及到*Windows*全局钩子*DLL*加载时的一种策略。全局钩子说到底就是程序*A*调用*SetWindowsHookEx*安装全局钩子的时候，会将全局钩子所在的*DLL*（记为*DLL-Hook*）加载到程序*A*的进程地址空间，然后系统做一定的记录得知要给所有的*GUI*线程加载该钩子。当程序*C*（一个新的程序）有符合规则的消息时，系统就将*DLL-Hook*加载到*C*的地址空间，并且调用相关函数。根据*《Windows核心编程》*中的介绍，系统是一般按照以下流程操作的：
   > 1. 程序A加载全局钩子后，系统便得知存在哪个消息（记为消息*D*）的全局钩子。当程序C接收到消息M时，系统发现此消息是有钩子的，便会查找此钩子的*DLL*是否已经加载到进程*C*的地址空间中。如果已经加载，跳过第二步到第三步；
   > 2. 如果进程*C*还没有加载*DLL-Hook*，则将*DLL-Hook*加载到进程*C*的地址空间，并且得到*DLL-Hook*的加载的基地址位置（*BaseAddress2*），然后查看*DLL-Hook*在进程A中的基地址位置（*BaseAddress1*），并且可以得到钩子处理函数在进程A中的地址（*ProcAddress1*），系统根据*BaseAddress1，BaseAddress2*和*ProcAddress1*，计算出钩子处理函数在进程*C*中的地址为*ProcAddress = BaseAddress2 + ProcAddress 1 - BaseAddress1*；同时将*DLL*的引用计数加1；
   > 3. 调用钩子处理函数；
   > 4. 进程*C*将*DLL-Hook*应用计数减1；
   经过分析，得知DLL-Hook是常驻在进程*A*的地址空间的，但是进程*C*总是临时加载*DLL-Hook*，当*DLL-Hook*较大时，就会降低速度。然而我的*DLL-Hook*中又会堵塞*I/O*性质的加载一个数M的数据文件，估计这个过程会导致超时。

   问题总需要解决，我们的解决方式是将巨大计算量和需要的大量数据的过程放入进程A中，当钩子检测到消息发生时，只需要给进程*A*发送一个消息，通知进程A进行操作。这样做就可以避免上面遇到的问题。

  屋漏偏逢连夜雨，船迟又遇打头风。我们在实施的过程中又遇到一个问题：就是钩子发送的消息不能送达进程*A*。此处顺便提到，由于某些需要，进程A是要在管理员权限下运行的。我提到这里，估计你已经知道原因了，对。就是*UAC*从中作梗。*UAC*是禁止权限较低的进程（如进程*C*）给权限较高的进程（如进程*A*）发送消息的，这样做的原因也是显而易见的，否则*UAC*就真的成摆设了。我也不知道怎么搞定这个问题，只能用最笨方法，将系统的UAC设置更改一下，重启，测试通过。当然这只是没有办法的办法。

  项目至此，大部分问题都解决，剩下的就是机器学习的过程了，由于和所学专业相近，没有遇到太大困难。

  但是此处还有一个疑问，就是上面基于超时的分析是基于*Low-Level*的钩子的，对于基于*DLL*的全局钩子是否成立待考证，但是从这个角度出发，分析的结果是适用的，也解决了其中的问题。